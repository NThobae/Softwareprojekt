Ich wÃ¼rde zumindest fÃ¼r den Einstieg zunÃ¤chst die IDE â€STM32CubeIDEâ€œ empfehlen:
https://www.st.com/en/development-tools/stm32cubeide.html#get-software

Diese ist fÃ¼r alle Plattformen verfÃ¼gbar und bringt ein paar komfortable Features mit. 
Bei Einrichtung eines neuen Projekts kann man die Zielplattform auswÃ¤hlen und bekommt 
dann schon ein paar Startup-Code-Files geschenkt.
Damit kommt man dann recht schnell dazu, dass das Board mit einem spricht.
Richtet euch doch mal diese IDE ein und versucht herauszufinden, ob und wie man die Dateien 
aus dem STM MCU Firmware Package importieren kann. Meine Hoffnung wÃ¤re (da beides aus demselben Haus kommt), 
dass in dem Firmware Package vielleicht sogar schon entsprechende Projektdateien enthalten sind.

#####################################################################################################

Wenn ihr die IDE heruntergeladen habt, kÃ¶nnt ihr ein neues Projekt fÃ¼r die Ziel-Plattform wie folgt erzeugen:
File â€”> New â€”> STM32 Project Ã¶ffnet ein neues Fenster. Das Laden kann einen Moment dauern.

In diesem Fenster wÃ¤hlt ihr oben links den Tab â€Board Selectorâ€œ aus und gebt in das Suchfeld
unter â€Part Number Searchâ€œ die Kennung eures Boards ein: â€NUCLEO-L552ZE-Qâ€œ. 
Dann wÃ¤hlt ihr das Board in der Ãœbersicht rechts aus. Nun habt ihr die MÃ¶glichkeit, 
auch direkt das Datasheet oder weitere Docs zu dem Board von dort herunterzuladen.
Auf jeden Fall empfehlenswert sind das Datasheet und das User Manual. 
Ihr werdet voraussichtlich viel mit Dokumentationen arbeiten mÃ¼ssen. Wollt ihr das neue Projekt erzeugen, klickt ihr unten rechts auf â€Nextâ€œ. 

#####################################################################################################

Attached Files: telegram-cloud-document-4-5897780835246934197.jpg

Dies ist dann die Eingabemaske fÃ¼r die weiteren Projektinformationen.
Achtet darauf, unten beim â€Targeted Project Typeâ€œ Empty auszuwÃ¤hlen,
auÃŸer ihr habt euch so sehr eingelesen, dass wir wisst, was die andere Auswahl macht ğŸ˜‰ 
Was man schon einmal machen kÃ¶nnte, bevor die Boards angekommen sind: 
Herausfinden, welchen Unterschied der Punkt â€Enable Trustzoneâ€œ macht.
Welche zusÃ¤tzlichen Projektdateien bekommt ihr dann geschenkt? 
Was machen die? Was muss man tun, um den Trustzone-Support des Boards selbst zu implementieren, 
wenn man nicht auf diese Funktion der IDE zurÃ¼ckgreifen mÃ¶chte.

######################################################################################################

Wenn die Boards dann angekommen sind, kÃ¶nnen die ersten Schritte in 2 Richtungen gehen. 
Ihr kÃ¶nnt euch sofort auf das MCU Firmware Package stÃ¼rzen und versuchen herauszufinden, wie ihr das aufs Board bekommt.
Oder ihr macht euch erst noch etwas besser mit dem Board vertraut. 
Wenn ihr euch fÃ¼r letzteres entscheidet kÃ¶nnte man zum Beispiel mal:
a) eine LED blinken lassen
b) ein Hello World Ã¼ber die Debug-Schnittstelle ausgeben

a) ist relativ generisch. Wenn ihr hier keinen Beispielcode oder ein Youtube-Video zu genau diesem Board findet,
hilft euch sehr wahrscheinlich auch ein Tutorial zu irgendeinem anderen STM Nucleo. Was muss man tun? 
In den Docs herausfinden, welche LEDs es gibt. Sich fÃ¼r eine LED entscheiden. Herausfinden,
Ã¼ber welche GPIO Pins diese LED gesteuert wird. Dann die sogenannte Peripheral Clock fÃ¼r diesen GPIO-Block enablen,
indem man das entsprechende Bit im entsprechenden Register setzt. Ich kenne dieses konkrete Board auch noch nicht,
in einem anderen STM Board heiÃŸt das Register zB RCC_AHB1ENR. AHB1 ist der Bus, an dem dieser GPIO-Block dran hÃ¤ngt. 
Wenn ihr hier Hilfe braucht und euch nicht recht in den Docs zurechtfindet, meldet euch bitte. 
Wenn die Clock aktiviert ist, dann muss das entsprechende Mode Register fÃ¼r diesen GPIO Pin auf Output gesetzt werden. 
Denn wir wollen den Zustand der LED ja schreiben und nicht lesen.
Und zuletzt dann das Output Data Register fÃ¼r diesen GPIO Pin am entsprechenden Bit setzen. 
Hier muss man zuerst mal ganz viel in den Docs herumlesen, bis man herausgefunden hat, 
wie die Register heiÃŸen und welche Bits man jeweils setzen mÃ¶chte.
Das kann man auch schon machen, bevor man das echte Board hat.
Den Code kÃ¶nnte man auch schon schreiben und dann testen, sobald das Board angekommen ist.
